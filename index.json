[{"categories":["AI Tools","Development"],"contents":"In the previous chapter, we learned how to use the /init command to create a CLAUDE.md file that gives Claude Code project-wide context. Now let\u0026rsquo;s explore how to provide specific context for individual tasks and manage context effectively to avoid bloat.\nWhat is Context? Context is additional relevant information that helps AI models provide more accurate responses. Just like in human conversations, saying \u0026ldquo;fix the link\u0026rdquo; without context is vague, but saying \u0026ldquo;fix the broken link in the navigation component\u0026rdquo; gives clear direction.\nWhile CLAUDE.md provides automatic project context, you\u0026rsquo;ll often need to add specific files, code sections, or images for targeted tasks.\nAdding Files as Context Use the @ symbol followed by a file path:\n1 @src/components/ui/button.tsx add a black variant with white text As you type, Claude shows file suggestions you can select with arrow keys. You can reference multiple files in a single prompt:\n1 @src/components/button.tsx @src/styles/theme.ts update button styles to match theme Adding Images as Context Add images to the chat session to provide visual context using either method:\nDrag and drop the image file into the chat Copy and paste with Ctrl + V (Linux/Windows) or Cmd + V (Mac) 1 2 3 [Drag image or paste with Ctrl + V] Can you update the button design in @src/components/button.tsx to look more like this image with a 3D effect, keeping all color variants? Claude can analyze the image and implement visual features like shadows, gradients, and effects.\nThe Context Bloat Problem Every prompt, response, and manually added file stays in context for the entire session. This is useful when working on a single feature, but problems arise when you:\nWork on one feature (e.g., shopping basket) Get sidetracked to fix something unrelated (e.g., button styling) Continue in the same session with all the basket context still loaded Result: Claude has irrelevant context that can confuse it and reduce accuracy.\nManaging Context 1. /clear - Complete Reset Clears entire session history and context, keeping only CLAUDE.md:\n1 /clear Best for: Starting fresh after completing a task.\n2. /compact - Summarize Session Compacts the session into a small summary, deleting the rest:\n1 /compact Best for: Long sessions on a single feature where context is getting bloated but you want to keep working on the same task.\n3. Double Escape - Rewind History Press Escape twice to rewind to a previous point in the session:\nNavigate through chat history Press Enter on any message to rewind there Everything after that point gets removed Best for: Removing recent digressions or debugging tangents.\n4. Exit and Resume Sessions Exit the current session:\n1 /exit Start a new session:\n1 claude Resume a previous session:\n1 /resume This shows all sessions with:\nLast used timestamp Message count Git branch Summary Select one to resume with full context intact.\nContext Window Limits Claude Code at this point in time has a 200,000 token context window (1 token ≈ 3-4 characters). Long sessions with many files eventually fill this limit.\nWarning signs:\nClaude notifies you when approaching the limit Results quality drops off Solution: Use /clear, /compact, or double escape to reduce context.\nBest Practices Keep context focused - Only add files relevant to the current task Clean between tasks - Use /clear when switching to unrelated work Use /compact for long sessions - When working on one feature over many prompts Leverage file selection - Highlight specific code sections instead of entire files Reference schemas/configs - Help Claude understand data structures and settings Add visual context - Use images for UI/design-related tasks Monitor context size - If results degrade, clear or compact Context Hierarchy Claude Code uses context in this order:\nSystem prompts - Built-in Claude Code instructions CLAUDE.md files - Project, local, and global memory Current session - Chat history and responses Manually added files - Files referenced with @ or opened Images - Visual context from dragged images By managing context effectively, you ensure Claude Code has exactly the information it needs—no more, no less—for optimal code generation.\n","permalink":"https://pauloportugal.github.io/post/2025-12-12-claude-code-3-context-management/","tags":["claude-code","ai","developer-tools","productivity"],"title":"Claude Code - Managing Context for Better Results"},{"categories":["AI Tools","Development"],"contents":"In the previous chapter, we covered what Claude Code is and how to get started. We walked through installation, first-time setup and best practices for working with Claude Code. Now that we have Claude Code up and running, it\u0026rsquo;s time to give it proper context about your project.\nWhy Use CLAUDE.md? Before making any code changes with Claude Code, you should initialize a CLAUDE.md file in your project root. This file acts as mini-documentation that Claude uses as context when making decisions about your code, leading to much better code generation that follows your project\u0026rsquo;s patterns.\nThe /init Command Run this command to have Claude scan your entire codebase and create a structured CLAUDE.md file:\n1 /init Claude will:\nAnalyze your folder structure Examine package.json and dependencies Identify state management patterns Review existing documentation Generate a comprehensive CLAUDE.md file The file is automatically added to session context, so Claude refers to it whenever making changes.\nWhat Gets Included? A typical CLAUDE.md file contains:\nDevelopment commands (npm scripts) Architecture overview (frameworks, libraries, versions) Project structure (where files belong) Data architecture (APIs, databases, CMS) Styling conventions (CSS approach, design system) Testing setup (test frameworks, patterns) Development notes (coding standards, preferences) Starting with a New Project If you\u0026rsquo;re starting fresh with minimal code, the generated CLAUDE.md will be sparse. In this case:\nManually edit the file to outline:\nHigh-level project structure plans Tools, packages, and frameworks you\u0026rsquo;ll use Code style preferences Application summary Update it as you go when things change\nAdding Memories from Chat Use the # symbol to add instructions directly from chat:\n1 # when making new page components, always add a link to that page in the header You\u0026rsquo;ll see options to save to:\nProject memory - CLAUDE.md (tracked in git, shared with team) Local project memory - CLAUDE.local.md (personal, not tracked) Global memory - ~/.config/claude/CLAUDE.md (applies to all projects) Memory Types Explained Project Memory (CLAUDE.md):\nTracked by version control Shared with all developers on the project Contains project-specific guidance (folder structure, naming conventions, frameworks) Local Project Memory (CLAUDE.local.md):\nPersonal preferences for this project only Not pushed to repository Your own tooling and workflow preferences Note: Being deprecated in favor of importing untracked files Global Memory (~/.config/claude/CLAUDE.md):\nPersonal guidance across ALL projects Your coding style preferences Tools you use globally Accessing Memory Files Use the /memory command to open and edit any memory file:\n1 /memory Select which file to edit (project, local, or global).\nKeep It Updated The CLAUDE.md file isn\u0026rsquo;t a \u0026ldquo;set and forget\u0026rdquo; document. Update it when:\nFile/folder structure changes Dependencies are added or removed Coding standards evolve New patterns are established If you don\u0026rsquo;t update it, Claude might not pick up on changes and could generate code that doesn\u0026rsquo;t match your current project structure.\nBest Practices Always run /init when bringing Claude Code into a project Review the generated file and add missing information Be specific with folder locations and naming conventions Update regularly as your project evolves Commit to git so the team shares the same context Use # in chat for quick memory additions during development By maintaining a good CLAUDE.md file, you keep Claude aligned with your project\u0026rsquo;s architecture and coding style, resulting in cleaner, more appropriate code generation.\n","permalink":"https://pauloportugal.github.io/post/2025-12-12-claude-code-2-memory-claude-md/","tags":["claude-code","ai","developer-tools"],"title":"Claude Code - Project Memory with CLAUDE.md"},{"categories":["AI Tools","Development"],"contents":" What is Claude Code? Claude Code is an AI-powered agentic coding tool created by Anthropic that helps you analyze, plan, write, and edit code within your projects. Unlike other AI coding tools like Copilot or Cursor that come with embedded UIs in code editors, Claude Code lives directly in the terminal, allowing seamless integration with your existing development workflow without forcing you to switch IDEs.\nKey Features:\nTerminal-based interface Deep codebase understanding GitHub workflow integration (automated code reviews, working on issues) Git repository awareness (branch management, commits, conflict resolution) Optional VS Code extension for enhanced features Installation Install Claude code globally:\nvia the Claude AI bash script\n1 curl -fsSL https://claude.ai/install.sh | bash of via npm:\n1 npm install -g @anthropic-ai/claude-code First-Time Setup Navigate to your project directory: 1 cd your-project Start Claude Code: 1 claude Follow the setup prompts:\nSign in with your subscription Authorize in the browser Trust the project files when prompted Optional - Enable Shift+Enter keybinding for multi-line input:\n1 /terminal-setup Best Practices Recommended Workflow:\nUse a hands-on approach, coding alongside Claude on focused tasks Review all code changes as they happen Check the work as you go to keep code clean and bug-free Avoid:\nLetting AI code everything autonomously This leads to bugs, sloppy code, and technical debt Getting Started Try asking Claude about your project:\n1 Can you provide me with a summary of what this project is? Claude will read your codebase and provide an overview, making it excellent for onboarding to new projects.\nClaude Code excels at understanding your codebase and generating tailored, appropriate code on a project-by-project basis, making it a powerful addition to your development toolkit.\nWhat\u0026rsquo;s Next? With Claude Code installed and configured, we will then look at:\nAdd project memory using a CLAUDE.md file Set up MCP servers for additional tools Create custom commands for common tasks Spin up sub-agents for parallel work ","permalink":"https://pauloportugal.github.io/post/2025-12-12-claude-code-1-introduction-setup/","tags":["claude-code","ai","developer-tools","terminal"],"title":"Claude Code - Introduction \u0026 Setup for Linux"},{"categories":["DevOps","Linux"],"contents":" Overview Setting up a fresh Linux installation can be a time-consuming and repetitive process. Every time you install Manjaro (or any Linux distribution), you face the same tedious tasks: installing your favorite applications, configuring your development environment, setting up tools, and tweaking system settings to match your preferences.\nEnter Manjaro Playbook - an Ansible-based automation framework that transforms this multi-hour ordeal into a single command execution. This project represents the \u0026ldquo;infrastructure as code\u0026rdquo; philosophy applied to personal workstation configuration.\nThe Problem It Solves After installing a fresh copy of Manjaro Linux with GNOME 3, you typically need to:\nInstall dozens of packages from official repositories Configure AUR (Arch User Repository) packages Set up development environments (Docker, Kubernetes, multiple language runtimes) Install and configure productivity tools Configure system services like firewalls and printers Customize GNOME settings Set up communication tools Doing this manually is error-prone, inconsistent, and wastes valuable time. Even worse, you can\u0026rsquo;t easily replicate your setup across multiple machines or recover quickly from system failures.\nArchitecture \u0026amp; Design Modular Role-Based Structure The playbook follows Ansible best practices with a modular, role-based architecture. Each role represents a logical component of your system configuration:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 manjaro-playbook/ ├── roles/ │ ├── base/ # System foundation packages │ ├── users/ # User account configuration │ ├── browsers/ # Web browsers │ ├── dev-tools/ # Development stack │ ├── editors/ # Code editors \u0026amp; IDEs │ ├── virtualization/ # Vagrant, VirtualBox │ ├── comms/ # Communication tools │ ├── cloud-tools/ # Cloud platform CLIs │ ├── multimedia/ # Media applications │ ├── audio-tools/ # Audio production │ ├── printers/ # Printing services │ ├── clamav/ # Antivirus │ └── ... This modular design provides several benefits:\nSelective Installation: Install only what you need using tags Maintainability: Each role is self-contained and easy to update Reusability: Roles can be shared across different playbooks Clarity: Clear separation of concerns makes the codebase understandable Package Management Strategy One of Manjaro Playbook\u0026rsquo;s strengths is how it handles multiple package sources:\nOfficial Repositories (Pacman): Core system packages and widely-used applications are installed via Manjaro\u0026rsquo;s official repositories using the pacman module.\nAUR Packages: The Arch User Repository provides access to thousands of community-maintained packages. The playbook uses pamac (Manjaro\u0026rsquo;s package manager) to automate AUR package installation, which is typically a manual process.\nCustom Scripts: For packages requiring special handling or those not available through standard channels, the playbook includes custom shell scripts.\nKey Features Development Environment Stack The dev-tools role is particularly comprehensive, installing a complete modern development stack:\nContainerization: Docker and Kubernetes (kubectl, minikube) Languages \u0026amp; Runtimes: Java (OpenJDK), Node.js, Go, Scala Build Tools: Maven, Gradle, npm Version Control: Git with configuration Cloud Tools: AWS CLI, Azure CLI, Google Cloud SDK All configured and ready to use after a single playbook run.\nTesting Infrastructure One of the most impressive aspects of this project is its testing infrastructure. Before deploying changes to your production system, you can:\nVagrant Testing: The playbook includes a complete Vagrant configuration that spins up a VirtualBox VM running Manjaro, applies the playbook, and lets you verify everything works correctly in isolation.\n1 2 # Test the entire playbook in a VM vagrant up This is a game-changer for safety - you never have to worry about a misconfigured playbook breaking your main system.\nCode Quality Automation The project implements several quality assurance mechanisms:\nPre-commit Hooks: Automatically validate code before commits YAML Linting: Ensures all YAML files follow best practices Ansible Linting: Checks playbooks against Ansible best practices CI/CD Pipeline: GitHub Actions automatically test changes This level of quality control ensures reliability and maintainability.\nGetting Started Prerequisites After a fresh Manjaro installation, you need:\n1 2 3 4 5 6 # Update system mirrors and packages sudo pacman-mirrors --fasttrack sudo pacman -Syu # Install Git and Ansible sudo pacman -S git ansible python-pip Installation Clone the repository and run the setup script:\n1 2 3 4 5 6 # Clone via SSH (requires GitHub SSH keys configured) git clone git@github.com:PauloPortugal/manjaro-playbook.git cd manjaro-playbook # Install dependencies ./setup.sh Running the Playbook The playbook requires three variables for execution:\n1 2 3 4 ansible-playbook main.yml \\ --extra-vars \u0026#34;username=your_username\u0026#34; \\ --extra-vars \u0026#34;git_user_name=\u0026#39;Your Name\u0026#39;\u0026#34; \\ --extra-vars \u0026#34;git_user_email=your@email.com\u0026#34; Selective Installation You can use Ansible tags to install only specific components:\n1 2 3 4 5 6 7 8 # Install only browsers ansible-playbook main.yml --tags browsers # Install development tools and editors ansible-playbook main.yml --tags dev-tools,editors # Install everything except virtualization ansible-playbook main.yml --skip-tags virtualization Real-World Use Cases Fresh Installation Recovery Scenario: Your SSD fails, and you need to set up a new system quickly.\nSolution: Install Manjaro, clone the playbook, run it. Within 30-60 minutes (depending on internet speed), you have your complete development environment back, configured exactly as it was.\nMulti-Machine Consistency Scenario: You work on multiple machines (desktop, laptop, work computer) and want identical environments.\nSolution: Run the same playbook on all machines. Every system will have the same tools, configurations, and settings.\nOnboarding New Team Members Scenario: Your team uses Manjaro, and new developers need standardized setups.\nSolution: Fork the playbook, customize it for your team\u0026rsquo;s needs, and provide it as an onboarding tool. New team members can be productive on day one.\nConfiguration Experimentation Scenario: You want to try new tools or configurations without risking your main system.\nSolution: Use the Vagrant testing infrastructure to experiment in a VM first, then apply successful changes to your production system.\nTechnical Highlights Idempotency The playbook is designed to be idempotent - you can run it multiple times safely. Ansible\u0026rsquo;s declarative approach ensures that:\nPackages already installed won\u0026rsquo;t be reinstalled Existing configurations won\u0026rsquo;t be overwritten unnecessarily The system converges to the desired state regardless of starting condition Error Handling \u0026amp; Debug Modes The playbook includes configurable verbosity levels:\n1 2 3 4 5 6 7 8 # Standard execution ansible-playbook main.yml # Verbose output for troubleshooting ansible-playbook main.yml -v # Maximum verbosity for debugging ansible-playbook main.yml -vvv Version Control \u0026amp; Release Management The project follows professional software engineering practices:\nSemantic Versioning: Clear version numbers indicating compatibility Change Tracking: Over 250 commits documenting evolution Release Notes: Detailed changelogs for each version GitHub Actions: Automated CI/CD pipeline Lessons Learned \u0026amp; Best Practices After maintaining this project across multiple releases, several best practices emerge:\nStart Small: Begin with a minimal playbook and gradually add roles as needed Test First: Always test in Vagrant before applying to production Document Everything: Use clear variable names and include comments explaining non-obvious choices Version Lock Critical Dependencies: Pin important package versions to avoid breakage Separate Secrets: Never commit sensitive data; use Ansible Vault for credentials Keep Roles Focused: Each role should do one thing well Tag Generously: Liberal use of tags provides flexibility in execution Future Enhancements While the current playbook is mature and functional, there\u0026rsquo;s always room for improvement:\nConfiguration Management: Externalize more configurations to variables files Dotfiles Integration: Automated management of shell configurations and dotfiles Backup Integration: Automated backup configuration and restoration Profile Variants: Different profiles for different use cases (development, gaming, content creation) Distribution Support: Extend support to other Arch-based distributions Conclusion The Manjaro Playbook represents automation done right - it solves a real problem, follows best practices, includes comprehensive testing, and maintains high code quality. Whether you\u0026rsquo;re setting up a new system, maintaining multiple machines, or just want to document your perfect development environment, infrastructure-as-code approaches like this playbook are invaluable.\nThe project demonstrates that personal automation projects can achieve the same professional standards as enterprise infrastructure code. By treating your workstation configuration as code, you gain reproducibility, consistency, and peace of mind knowing you can rebuild your environment at any time.\nIf you\u0026rsquo;re running Manjaro (or considering it), or if you\u0026rsquo;re interested in infrastructure automation, I highly recommend exploring this approach. The time invested in creating a robust automation playbook pays dividends every time you need to set up or recover a system.\nResources Project Repository: github.com/PauloPortugal/manjaro-playbook Ansible Documentation: docs.ansible.com Manjaro Linux: manjaro.org Arch User Repository: aur.archlinux.org Happy automating! May your systems always converge to their desired state. {: .prompt-tip }\n","permalink":"https://pauloportugal.github.io/post/2025-12-11-automating-manjaro-setup-with-ansible/","tags":["ansible","manjaro","automation","infrastructure-as-code","linux","devops"],"title":"Automating Manjaro Setup with Ansible"},{"categories":null,"contents":"Chirpy is a blog theme originally based on Jekyll. Due to Jekyll\u0026rsquo;s design limitations, it does not natively support internationalization (i18n) and requires third-party plugins for i18n functionality. To enable i18n support for Chirpy without the hassle of relying on third-party plugins, the hugo-theme-chirpy project migrated the Chirpy theme to Hugo with minimal adaptations. All features of Chirpy are available in hugo-theme-chirpy (though some functionalities may operate differently within the Hugo framework).\nFollow the posts in the demo site to quickly set up a free personal blog!\nFeatures Dark Mode: Enhanced readability in low-light environments. Multilingual UI: Easily switch between different languages. Efficient Post Organization: Use hierarchical categories, trending tags, recommended reading, and search functionalities. Optimized Layout: Includes TOC, syntax highlighting, prompts, and more. Rich Writing Extensions: Support for mathematical formulas, charts, flowcharts, and embedded media. Multiple Comment Systems: Choose from various commenting options. Web Analysis Tools: Integrated with multiple analytics tools. Modern Web Technologies: Built for SEO and web performance. RSS Feed Support: Keep your readers updated with RSS feeds. ","permalink":"https://pauloportugal.github.io/about/","tags":null,"title":"About"},{"categories":null,"contents":"","permalink":"https://pauloportugal.github.io/archives/","tags":null,"title":"Archives"}]